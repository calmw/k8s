#### 介绍

    Pod这个名字来源于Docker的鲸鱼🐳主题，因为Pod的意思是一群鲸鱼。
    Pod 代表Kubernetes集群中的原子工作单元。Pod由一个或者多个共生的容器组成。Pod代表了在同一个执行环境中运行的应用程序容器和卷的集合。Kubernetes集群中最小可部署的单元是Pod（而非容器）。这意味着Pod中所有容器都会被调度到同一台机器上。只要有足够的资源，多个Pod可以被安排到同一台计算机上。然而将同一个应用程序的多个副本调度到同一台计算机上则会导致可靠性降低，因为这台计算机将成为单一故障点。因此Kubernetes调度器会设法将同一个应用程序的Pod分散到多台机器上，以此来确保发生故障时的可靠性。
    Pod中的每个容器都在自己的cgroup中运行，但是他们共享许多Linux命名空间。在同一个Pod中运行的应用程序共享同一个IP地址和端口空间（网络命名空间），拥有相同的主机名（UTS命名空间），而且还可以使用System V IPC或POSIX消息队列（IPC命名空间）上本地进程间的通信通道进行通信。不同Pod中的应用程序是互相隔离的。它们拥有不同的IP地址，不同的主机名等。在同一节点上运行的不同Pod中的容器也可能位于不同的服务器上。
        我们应该将哪些容器放入同一个Pod？
            在设计Pod时需要考虑：如果将这些容器放到不同的机器上，他们是否可以正常工作？如果答案为否，则应该将这些容器分组到同一个Pod中。如果答案为是，则采用多个Pod才是正确的解决方案。举例说明：Wordpress和mysql，放在不同机器上可以工作，他们不应该在一个Pod中，后期伸缩策略也不同，显然也不合适在一个Pod中。
    创建Pod的方式包括两种：
        1）编写Pod清单，并通过命令行工具将清单提交到KubernetesAPI服务器
        2）通过HTTP和JSON直接调用服务器（不推荐）
    将清单提交到API服务器后，Kubernetes调度器为Pod找到合适的机器，并将Pod调度到机器上。接下来，由该机器上的守护进程kubelet负责创建Pod相应的容器，并执行Pod清单中的健康检查。
    在Pod被调度到某个节点之后，即便该节点发生故障，也不会重新调度。此外，如果想创建同一个Pod的多个副本，你必须手动执行创建和命名。

#### 创建Pod

    1）创建最简单的方法是直接运行kubectl run 命令, 详细请查看kubectl run --help
            kubectl run kuard --image=gcr.io/kuard-demo/kuard-amd64:blue 
        可以通过运行以下命令来查看这个Pod的状态
            kubectl get pods 
            刚开始的时候，容器状态为ContainerCreating、pending，但它最终会转变为running，表示Pod及其容器创建成功。
        可以通过运行以下命令删除Pod
            kubectl delete pods/kuard 
    2）可以采用YAML或JSON格式编写Pod清单，然后使用命令指定该清单来运行Pod
        kubectl apply -f kuard-pod.yaml
        这个命令可以将Pod清单提交到KubernetesAPI服务器。然后由Kubernetes系统将该Pod调度到集群中运行状况良好的节点上，然后再由Kubelet守护进程对其进行监控。

#### 查询Pod

    查看Pod列表，可通过下面命令查看
        kubectl get pods
    查看某个Pod的详细信息
        kubectl describe pods kuard

#### 删除Pod

    1）可以利用Pod名称来删除Pod
        kubectl delete pods/kuard
    2)使用创建Pod时的同一文件来删除Pod
        kubectl delete -f kuard-pod.yaml
    删除Pod时，Pod不会立即被干掉。如果你运行kubectl get pods,则可以看到Pod处于Terminating状态。所有Pod都有终止宽限期，默认为30。进入Terminating状态的Pod不会再接受新请求。
    删除Pod时存储在相关容器中的所有数据也会被删除。如果你想让Pod跨多个实例持久保存数据，则需要使用持久卷。

#### 访问Pod

    1）端口转发
        你经常访问某个特定的Pod，即使这个Pod并不向互联网提供服务，为了实现这一点，你可以使用KubernetesAPI和命令行工具自带的端口转发。
            kubectl port-forward kuard 8080:8080
            以上命令将创建一条安全的隧道，该隧道从本计算机开始，经由Kubernetes的主节点，连接到在其中一个工作节点上运行的Pod实例。在port-forward命令运行期间，你可以通过http://localhost:8080访问Pod（本示例时kuard的web界面）。
    2）获取日志
        kubectl logs 命令能够下载正在运行的实例的当前日志
            kubectl logs kuard
            如果加上 -f 标志，则可以连续的输出日志
            此方法可以在生产环境中针对容器进行一次性的调试。但一般情况下使用日志聚合服务更方便。常用的日志聚合工具包括fluentd和elasticsearch，还有众多基于云的日志服务。
    3）使用exec在容器中运行命令
        kubectl exec -it kuard ash
    4）在容器之间复制文件
        运行以下命令将文件(/xxx/finename.txt)复制到本地计算机上
            kubectl cp <pod名称>:/xxx/finename.txt filename.txt
        将文件从本地计算机复制到容器中
            kubectl cp $HOME/Desktop/a.txt <pod名称>:/home/a.txt

#### 健康检查

    1） 探针检查
        1） 存活探针
            一个存活探针，该探针会针对容器的/healthy路径发送HTTP请求，可查看示例文件的livenessProbe部分
                使用了一个httpGet探针，针对kuard容器端口8080上的/healthy端点发送HTTP GET 请求
                initialDelaySeconds: 5 等到所有的容器都创建成功5s后该探针才会被调用
                timeoutSeconds: 1 该探针必须在一秒内响应，而且http状态码必须大于200且小于400才能被视为成功
                periodSeconds: 10 每隔10s调用一次探针
                failureThreshold: 3 如果探针连续（注意这里是连续）失败三次以上。则Kubernetes会认为容器发生了故障，并重启容器
            重启策略（restartPolicy），尽管存活探针失败后的默认响应是重启Pod，但实际行为由Pod的重启策略（restartPolicy）控制，重启策略有三个选项：Always（默认值）、OnFailure（仅在存活探针失败或进程退出码为非零时重启）或Never（永不重启）。
        2）就绪探针
            就绪探针表明容器何时准备好服务用户请求，就绪探针的配置与存活探针类似
        总结：存活探针决定应用程序是否正常运行。凡是未通过存活探针的容器都会被重启。而就绪探针则表明容器何时准备好服务用户请求。凡是未通过就绪探针的容器都会从服务负载均衡器中移除。
    2）健康检查的类型
        1）http检查
        2）tcpSocket检查
            这种健康检查能够打开TCP套接字，如果连接成功则探针成功。这种类型可以用于非http应用程序，如数据库或其他不基于http的API。
        3）exec探针
            这些探针可以在容器的上下文中执行脚本或程序。按照通常的约定，如果脚本执行的退出码为0，则表示成功，否则代表失败。exec脚本常用于不适合http调用的自定义应用程序验证逻辑

#### 资源管理

    由于Kubernetes的容器和编排极大的改进了镜像和打包，而且还提供了可靠的部署，因此大多数人都采用这些技术。K8S不仅提供了面向应用程序的原语，降低了分布式系统的开发难度，而且还提高了组成集群的各个节点的整体资源利用率。
    使用K8S之类的调度器来管理资源打包，可以将利用率提高50%以上。为了实现这一点，你必须告诉K8S应用程序需要多少资源，只有这样K8S才能找到在已购买的机器上对容器进行打包的最佳方式。
    除了设置Pod所需最小资源量（resources requests），还可以设置Pod的最大资源使用量（resources limits）。
    当只设置最小值：
        将Pod调度到节点时，调度器需要使用到请求值（最小资源使用量）。K8S会确保节点上所有请求资源总和不超过该节点的容量（比如某机器的总资源量）。因此Pod在节点上运行时，至少能获取到请求的资源量（最小资源量）。
            假设我们有一个容器，其代码会耗尽所有可用的CPU核心。假设我们用这样的容器创建一个Pod，请求0.5个CPU。K8S将这个Pod调度到一个有2个CPU的核心机器上。当这个Pod是这个机器上唯一的Pod时，它会耗尽所有可用的2个核心，尽管Pod只请求了0.5个核心。如果另外一个Pod拥有相同的容器也被调度到这台机器上，每个Pod会消耗1个核心。如果同样三个Pod都被调度到这台机器上，那么每个Pod会消耗0.66个核心。最后等到四个同样的Pod被调度到这台机器上后，每个Pod消耗0.5个核心，而这个节点（这台机器）将处于满负荷状态。
            CPU的请求是通过Linux内核中的cpu-shares功能实现的。
        内存请求的处理方式与CPU类似，但二者有一个重要区别。如果容器使用内存超出请求，则操作系统无法简单的从进程中删除内存，因为内存已被分配出去了。因此当系统内存不足时，Kubelet会终止内存使用量大于请求值的容器。这些容器会自动重启，该容器能使用的内存量会减小。
    当最小值和最大值都设置：
        对于CPU约束0.5个内核（这里用请求来表示最小值，约束表示最大值）的容器来说，即使有闲置的CPU，它永远只能获得0.5个内核。如果内存约束256MB的容器，它使用的内存量超过256MB则再也无法获得更多内存（例如malloc会失败）
    也就是说，如果只设置了最小值，他们是可以使用超过最小值的资源的，当系统资源不足时会做出相应的处理。如果设置了最大值，它就不能超出最大值。

#### 使用卷持久保存数据
    Pod中两个不同的容器可以使用不同的加载路径加载同一个卷。
    


#### Pod yaml文件示例：

- 示例文件 [**kuard-pod.yaml**](../demo/kuard-pod-demo.yaml)
