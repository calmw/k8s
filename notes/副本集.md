#### 介绍

    常常需要在特定的时间点运行多个容器的副本，原因有多个方面：
        1）冗余：运行多个实例可以保障容错性
        2）规模：运行多个实例可以处理更多请求
        3）分片：不同的副本可以并行处理计算的不同部分
    从逻辑上讲，用户在管理一组相同的Pod时，会将他们视为一个示例来定义和管理。而这正是副本集(ReplicaSet)的概念，也就是说副本集主要针对一组相同的Pod

#### 副本集的伸缩

    当副本集规模收缩时，被删除的Pod也是随机选择的。
    创建副本集：
        kubectl aply -f kuard-rs.yaml
    查看副本集详情：
        kubectl decribe rs kuard
    扩展副本集：
        kubectl scale replicasets kuard --replicas=4  //将运行的副本集扩展到四个
        尽管在演示时或者需要快速处理的紧急情况（例如，响应负载陡然激增）时，这种命令式的操作非常方便，但事后一定要更新文本文件配置，以匹配你通过命令式设置的副本集数量。举个例子：如果处理紧急情况时，更改了副本集数量而没有更新文本配置，几天后有新功能发布，副本集的数量依旧为扩容之前的数量，此时很容易忘记更新到线上当前的副本数量，这样会导致发布更新后，可能当场就引发了过载或中断。
        所以，执行完伸缩命令后，立即修改源代码控制中的声明式配置（yaml文件）。
    收缩副本集：
        更改yaml文件中的副本配置数量，然后通过kubectl apply提交到API服务器（跟创建一样）。

#### 自动伸缩副本集

    虽然有时你需要明确控制副本集的数量，但通常你只希望拥有"足够"的副本。这个"足够"因副本集中的容器需求而已。例如：对于nginx等web服务器，你可能需要根据CPU使用率进行扩展。对于内存缓存服务器，你可能需要希望随着内存的消耗量进行扩展。
    K8S的自动伸缩分为水平伸缩和垂直伸缩两种。其中水平伸缩是创建额外的Pod副本；而垂直伸缩则需要增加Pod所需的资源（例如Pod所需的CPU）。目前K8S未实现垂直伸缩。
    基于CPU的自动伸缩：
        基于CPU的自动伸缩是最常见的Pod伸缩。通常这种方式适合基于请求的系统，这类系统消耗的CPU和接收的请求数量成正比，而内存使用相对固定。如下命令可实现基于CPU的自动伸缩
        kubectl autoscale rs kuard --min=2 --max=5 --cpu-percent=80
        这个命令会创建一个自动伸缩器，副本数量可以在2～5之间伸缩，CPU阀值为80%。如果查找相关命令可以使用命令： kubectl get hpa
    在启用自动伸缩的情况下，同时以命令或声明式来管理副本数量可不是好主意。如果你和自动伸缩器都想修改副本数量，则有可能会发生冲突，从而导致意外行为。
    自动伸缩查看、编辑和删除:
        kubectl get hpa
        kubectl edit hpa rsName
        kubectl delete hpa rsName

#### 删除副本集

    删除副本集可以用以下命令，删除副本集的同时会删除副本集管理的Pod
        kubectl delete rs kuard
    如果想删除副本集而不删除Pod，可以使用下面命令
        kubectl delete rs kuard --cascade=false

#### 小结

    我们应该使用副本集来管理Pod，即便只有一个Pod！ 有些人甚至默认使用副本集而不是用Pod